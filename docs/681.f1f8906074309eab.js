"use strict";(self.webpackChunksmitd_game_poc=self.webpackChunksmitd_game_poc||[]).push([[681],{7013:(ce,z,O)=>{O.d(z,{z:()=>K});class K extends class o{constructor(_,E,g="WorldObject"){this.mesh=_,this.rigidBody=E,_.userData.type=g,_.userData.object=this,E.userData={},E.userData.type=g,E.userData.object=this}get model(){return this.mesh}get physicsBody(){return this.rigidBody}}{constructor(_,E,g,A="Character"){super(_,E,A),this.state=g}get animation(){return this.state.animationState}set animation(_){this.state.animationState=_}get info(){return this.state.info}set info(_){this.state.info=_}}},1509:(ce,z,O)=>{O.d(z,{E:()=>K});var o=O(6682);class K extends o.aNw{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new k(t)}),this.register(function(t){return new R(t)}),this.register(function(t){return new m(t)}),this.register(function(t){return new w(t)}),this.register(function(t){return new C(t)}),this.register(function(t){return new b(t)}),this.register(function(t){return new J(t)}),this.register(function(t){return new A(t)}),this.register(function(t){return new M(t)}),this.register(function(t){return new E(t)}),this.register(function(t){return new f(t)})}load(e,t,r,s){const i=this;let n;n=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:o.Zp0.extractUrlBase(e),this.manager.itemStart(e);const l=function(c){s?s(c):console.error(c),i.manager.itemError(e),i.manager.itemEnd(e)},a=new o.hH6(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(c){try{i.parse(c,n,function(d){t(d),i.manager.itemEnd(e)},l)}catch(d){l(d)}},r,l)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,r,s){let i;const n={},l={};if("string"==typeof e)i=e;else if(o.Zp0.decodeText(new Uint8Array(e,0,4))===T){try{n[_.KHR_BINARY_GLTF]=new P(e)}catch(u){return void(s&&s(u))}i=n[_.KHR_BINARY_GLTF].content}else i=o.Zp0.decodeText(new Uint8Array(e));const a=JSON.parse(i);if(void 0===a.asset||a.asset.version[0]<2)return void(s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const c=new Le(a,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let d=0;d<this.pluginCallbacks.length;d++){const u=this.pluginCallbacks[d](c);l[u.name]=u,n[u.name]=!0}if(a.extensionsUsed)for(let d=0;d<a.extensionsUsed.length;++d){const u=a.extensionsUsed[d],x=a.extensionsRequired||[];switch(u){case _.KHR_MATERIALS_UNLIT:n[u]=new g;break;case _.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:n[u]=new pe;break;case _.KHR_DRACO_MESH_COMPRESSION:n[u]=new q(a,this.dracoLoader);break;case _.KHR_TEXTURE_TRANSFORM:n[u]=new ne;break;case _.KHR_MESH_QUANTIZATION:n[u]=new V;break;default:x.indexOf(u)>=0&&void 0===l[u]&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}c.setExtensions(n),c.setPlugins(l),c.parse(r,s)}parseAsync(e,t){const r=this;return new Promise(function(s,i){r.parse(e,t,s,i)})}}function Y(){let p={};return{get:function(e){return p[e]},add:function(e,t){p[e]=t},remove:function(e){delete p[e]},removeAll:function(){p={}}}}const _={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class E{constructor(e){this.parser=e,this.name=_.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let r=0,s=t.length;r<s;r++){const i=t[r];i.extensions&&i.extensions[this.name]&&void 0!==i.extensions[this.name].light&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,r="light:"+e;let s=t.cache.get(r);if(s)return s;const i=t.json,a=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let c;const d=new o.Ilk(16777215);void 0!==a.color&&d.fromArray(a.color);const u=void 0!==a.range?a.range:0;switch(a.type){case"directional":c=new o.Ox3(d),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new o.cek(d),c.distance=u;break;case"spot":c=new o.PMe(d),c.distance=u,a.spot=a.spot||{},a.spot.innerConeAngle=void 0!==a.spot.innerConeAngle?a.spot.innerConeAngle:0,a.spot.outerConeAngle=void 0!==a.spot.outerConeAngle?a.spot.outerConeAngle:Math.PI/4,c.angle=a.spot.outerConeAngle,c.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return c.position.set(0,0,0),c.decay=2,void 0!==a.intensity&&(c.intensity=a.intensity),c.name=t.createUniqueName(a.name||"light_"+e),s=Promise.resolve(c),t.cache.add(r,s),s}createNodeAttachment(e){const t=this,r=this.parser,i=r.json.nodes[e],l=(i.extensions&&i.extensions[this.name]||{}).light;return void 0===l?null:this._loadLight(l).then(function(a){return r._getNodeRef(t.cache,l,a)})}}class g{constructor(){this.name=_.KHR_MATERIALS_UNLIT}getMaterialType(){return o.vBJ}extendParams(e,t,r){const s=[];e.color=new o.Ilk(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const n=i.baseColorFactor;e.color.fromArray(n),e.opacity=n[3]}void 0!==i.baseColorTexture&&s.push(r.assignTexture(e,"map",i.baseColorTexture,o.knz))}return Promise.all(s)}}class A{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name].emissiveStrength;return void 0!==i&&(t.emissiveIntensity=i),Promise.resolve()}}class k{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const r=this.parser.json.materials[e];return r.extensions&&r.extensions[this.name]?o.EJi:null}extendMaterialParams(e,t){const r=this.parser,s=r.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],n=s.extensions[this.name];if(void 0!==n.clearcoatFactor&&(t.clearcoat=n.clearcoatFactor),void 0!==n.clearcoatTexture&&i.push(r.assignTexture(t,"clearcoatMap",n.clearcoatTexture)),void 0!==n.clearcoatRoughnessFactor&&(t.clearcoatRoughness=n.clearcoatRoughnessFactor),void 0!==n.clearcoatRoughnessTexture&&i.push(r.assignTexture(t,"clearcoatRoughnessMap",n.clearcoatRoughnessTexture)),void 0!==n.clearcoatNormalTexture&&(i.push(r.assignTexture(t,"clearcoatNormalMap",n.clearcoatNormalTexture)),void 0!==n.clearcoatNormalTexture.scale)){const l=n.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new o.FM8(l,l)}return Promise.all(i)}}class w{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_SHEEN}getMaterialType(e){const r=this.parser.json.materials[e];return r.extensions&&r.extensions[this.name]?o.EJi:null}extendMaterialParams(e,t){const r=this.parser,s=r.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new o.Ilk(0,0,0),t.sheenRoughness=0,t.sheen=1;const n=s.extensions[this.name];return void 0!==n.sheenColorFactor&&t.sheenColor.fromArray(n.sheenColorFactor),void 0!==n.sheenRoughnessFactor&&(t.sheenRoughness=n.sheenRoughnessFactor),void 0!==n.sheenColorTexture&&i.push(r.assignTexture(t,"sheenColorMap",n.sheenColorTexture,o.knz)),void 0!==n.sheenRoughnessTexture&&i.push(r.assignTexture(t,"sheenRoughnessMap",n.sheenRoughnessTexture)),Promise.all(i)}}class C{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const r=this.parser.json.materials[e];return r.extensions&&r.extensions[this.name]?o.EJi:null}extendMaterialParams(e,t){const r=this.parser,s=r.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],n=s.extensions[this.name];return void 0!==n.transmissionFactor&&(t.transmission=n.transmissionFactor),void 0!==n.transmissionTexture&&i.push(r.assignTexture(t,"transmissionMap",n.transmissionTexture)),Promise.all(i)}}class b{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_VOLUME}getMaterialType(e){const r=this.parser.json.materials[e];return r.extensions&&r.extensions[this.name]?o.EJi:null}extendMaterialParams(e,t){const r=this.parser,s=r.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],n=s.extensions[this.name];t.thickness=void 0!==n.thicknessFactor?n.thicknessFactor:0,void 0!==n.thicknessTexture&&i.push(r.assignTexture(t,"thicknessMap",n.thicknessTexture)),t.attenuationDistance=n.attenuationDistance||0;const l=n.attenuationColor||[1,1,1];return t.attenuationColor=new o.Ilk(l[0],l[1],l[2]),Promise.all(i)}}class J{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_IOR}getMaterialType(e){const r=this.parser.json.materials[e];return r.extensions&&r.extensions[this.name]?o.EJi:null}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name];return t.ior=void 0!==i.ior?i.ior:1.5,Promise.resolve()}}class M{constructor(e){this.parser=e,this.name=_.KHR_MATERIALS_SPECULAR}getMaterialType(e){const r=this.parser.json.materials[e];return r.extensions&&r.extensions[this.name]?o.EJi:null}extendMaterialParams(e,t){const r=this.parser,s=r.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],n=s.extensions[this.name];t.specularIntensity=void 0!==n.specularFactor?n.specularFactor:1,void 0!==n.specularTexture&&i.push(r.assignTexture(t,"specularIntensityMap",n.specularTexture));const l=n.specularColorFactor||[1,1,1];return t.specularColor=new o.Ilk(l[0],l[1],l[2]),void 0!==n.specularColorTexture&&i.push(r.assignTexture(t,"specularColorMap",n.specularColorTexture,o.knz)),Promise.all(i)}}class R{constructor(e){this.parser=e,this.name=_.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,r=t.json,s=r.textures[e];if(!s.extensions||!s.extensions[this.name])return null;const i=s.extensions[this.name],n=t.options.ktx2Loader;if(!n){if(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,n)}}class m{constructor(e){this.parser=e,this.name=_.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,r=this.parser,s=r.json,i=s.textures[e];if(!i.extensions||!i.extensions[t])return null;const n=i.extensions[t],l=s.images[n.source];let a=r.textureLoader;if(l.uri){const c=r.options.manager.getHandler(l.uri);null!==c&&(a=c)}return this.detectSupport().then(function(c){if(c)return r.loadTextureImage(e,n.source,a);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return r.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(1===t.height)}})),this.isSupported}}class f{constructor(e){this.name=_.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,r=t.bufferViews[e];if(r.extensions&&r.extensions[this.name]){const s=r.extensions[this.name],i=this.parser.getDependency("buffer",s.buffer),n=this.parser.options.meshoptDecoder;if(!n||!n.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([i,n.ready]).then(function(l){const a=s.byteOffset||0,c=s.byteLength||0,d=s.count,u=s.byteStride,x=new ArrayBuffer(d*u),S=new Uint8Array(l[0],a,c);return n.decodeGltfBuffer(new Uint8Array(x),d,u,S,s.mode,s.filter),x})}return null}}const T="glTF";class P{constructor(e){this.name=_.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,12);if(this.header={magic:o.Zp0.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==T)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const r=this.header.length-12,s=new DataView(e,12);let i=0;for(;i<r;){const n=s.getUint32(i,!0);i+=4;const l=s.getUint32(i,!0);if(i+=4,1313821514===l){const a=new Uint8Array(e,12+i,n);this.content=o.Zp0.decodeText(a)}else if(5130562===l){const a=12+i;this.body=e.slice(a,a+n)}i+=n}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class q{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=_.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const r=this.json,s=this.dracoLoader,i=e.extensions[this.name].bufferView,n=e.extensions[this.name].attributes,l={},a={},c={};for(const d in n){const u=Q[d]||d.toLowerCase();l[u]=n[d]}for(const d in e.attributes){const u=Q[d]||d.toLowerCase();if(void 0!==n[d]){const x=r.accessors[e.attributes[d]];c[u]=W[x.componentType],a[u]=!0===x.normalized}}return t.getDependency("bufferView",i).then(function(d){return new Promise(function(u){s.decodeDracoFile(d,function(x){for(const S in x.attributes){const B=x.attributes[S],N=a[S];void 0!==N&&(B.normalized=N)}u(x)},l,c)})})}}class ne{constructor(){this.name=_.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),void 0===t.offset&&void 0===t.rotation&&void 0===t.scale||(e=e.clone(),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class te extends o.Wid{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),r=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),s=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),i=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),n=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),l={specular:{value:(new o.Ilk).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=l,this.onBeforeCompile=function(a){for(const c in l)a.uniforms[c]=l[c];a.fragmentShader=a.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",r).replace("#include <roughnessmap_fragment>",s).replace("#include <metalnessmap_fragment>",i).replace("#include <lights_physical_fragment>",n)},Object.defineProperties(this,{specular:{get:function(){return l.specular.value},set:function(a){l.specular.value=a}},specularMap:{get:function(){return l.specularMap.value},set:function(a){l.specularMap.value=a,a?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return l.glossiness.value},set:function(a){l.glossiness.value=a}},glossinessMap:{get:function(){return l.glossinessMap.value},set:function(a){l.glossinessMap.value=a,a?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(e){return super.copy(e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class pe{constructor(){this.name=_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return te}extendParams(e,t,r){const s=t.extensions[this.name];e.color=new o.Ilk(1,1,1),e.opacity=1;const i=[];if(Array.isArray(s.diffuseFactor)){const n=s.diffuseFactor;e.color.fromArray(n),e.opacity=n[3]}if(void 0!==s.diffuseTexture&&i.push(r.assignTexture(e,"map",s.diffuseTexture,o.knz)),e.emissive=new o.Ilk(0,0,0),e.glossiness=void 0!==s.glossinessFactor?s.glossinessFactor:1,e.specular=new o.Ilk(1,1,1),Array.isArray(s.specularFactor)&&e.specular.fromArray(s.specularFactor),void 0!==s.specularGlossinessTexture){const n=s.specularGlossinessTexture;i.push(r.assignTexture(e,"glossinessMap",n)),i.push(r.assignTexture(e,"specularMap",n,o.knz))}return Promise.all(i)}createMaterial(e){const t=new te(e);return t.fog=!0,t.color=e.color,t.map=void 0===e.map?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=void 0===e.aoMap?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=void 0===e.emissiveIntensity?1:e.emissiveIntensity,t.emissiveMap=void 0===e.emissiveMap?null:e.emissiveMap,t.bumpMap=void 0===e.bumpMap?null:e.bumpMap,t.bumpScale=1,t.normalMap=void 0===e.normalMap?null:e.normalMap,t.normalMapType=o.IOt,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=void 0===e.specularMap?null:e.specularMap,t.specular=e.specular,t.glossinessMap=void 0===e.glossinessMap?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=void 0===e.envMap?null:e.envMap,t.envMapIntensity=1,t}}class V{constructor(){this.name=_.KHR_MESH_QUANTIZATION}}class U extends o._C8{constructor(e,t,r,s){super(e,t,r,s)}copySampleValue_(e){const t=this.resultBuffer,r=this.sampleValues,s=this.valueSize,i=e*s*3+s;for(let n=0;n!==s;n++)t[n]=r[i+n];return t}}U.prototype.beforeStart_=U.prototype.copySampleValue_,U.prototype.afterEnd_=U.prototype.copySampleValue_,U.prototype.interpolate_=function(p,e,t,r){const s=this.resultBuffer,i=this.sampleValues,n=this.valueSize,l=2*n,a=3*n,c=r-e,d=(t-e)/c,u=d*d,x=u*d,S=p*a,B=S-a,N=-2*x+3*u,L=x-u,I=1-N,ee=L-u+d;for(let H=0;H!==n;H++)s[H]=I*i[B+H+n]+ee*(i[B+H+l]*c)+N*i[S+H+n]+L*(i[S+H]*c);return s};const y=new o._fP;class D extends U{interpolate_(e,t,r,s){const i=super.interpolate_(e,t,r,s);return y.fromArray(i).normalize().toArray(i),i}}const W={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},X={9728:o.TyD,9729:o.wem,9984:o.YLQ,9985:o.qyh,9986:o.aH4,9987:o.D1R},$={33071:o.uWy,33648:o.OoA,10497:o.rpg},G={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Q={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Z={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},ie={CUBICSPLINE:void 0,LINEAR:o.NMF,STEP:o.Syv};function ue(p,e,t){for(const r in t.extensions)void 0===p[r]&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[r]=t.extensions[r])}function F(p,e){void 0!==e.extras&&("object"==typeof e.extras?Object.assign(p.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Re(p,e){if(p.updateMorphTargets(),void 0!==e.weights)for(let t=0,r=e.weights.length;t<r;t++)p.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(p.morphTargetInfluences.length===t.length){p.morphTargetDictionary={};for(let r=0,s=t.length;r<s;r++)p.morphTargetDictionary[t[r]]=r}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Ae(p){const e=p.extensions&&p.extensions[_.KHR_DRACO_MESH_COMPRESSION];let t;return t=e?"draco:"+e.bufferView+":"+e.indices+":"+Se(e.attributes):p.indices+":"+Se(p.attributes)+":"+p.mode,t}function Se(p){let e="";const t=Object.keys(p).sort();for(let r=0,s=t.length;r<s;r++)e+=t[r]+":"+p[t[r]]+";";return e}function Me(p){switch(p){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class Le{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Y,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const r=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),s=navigator.userAgent.indexOf("Firefox")>-1,i=s?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;this.textureLoader="undefined"==typeof createImageBitmap||r||s&&i<98?new o.dpR(this.options.manager):new o.QRU(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new o.hH6(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const r=this,s=this.json,i=this.extensions;this.cache.removeAll(),this._invokeAll(function(n){return n._markDefs&&n._markDefs()}),Promise.all(this._invokeAll(function(n){return n.beforeRoot&&n.beforeRoot()})).then(function(){return Promise.all([r.getDependencies("scene"),r.getDependencies("animation"),r.getDependencies("camera")])}).then(function(n){const l={scene:n[0][s.scene||0],scenes:n[0],animations:n[1],cameras:n[2],asset:s.asset,parser:r,userData:{}};ue(i,l,s),F(l,s),Promise.all(r._invokeAll(function(a){return a.afterRoot&&a.afterRoot(l)})).then(function(){e(l)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],r=this.json.meshes||[];for(let s=0,i=t.length;s<i;s++){const n=t[s].joints;for(let l=0,a=n.length;l<a;l++)e[n[l]].isBone=!0}for(let s=0,i=e.length;s<i;s++){const n=e[s];void 0!==n.mesh&&(this._addNodeRef(this.meshCache,n.mesh),void 0!==n.skin&&(r[n.mesh].isSkinnedMesh=!0)),void 0!==n.camera&&this._addNodeRef(this.cameraCache,n.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,r){if(e.refs[t]<=1)return r;const s=r.clone(),i=(n,l)=>{const a=this.associations.get(n);null!=a&&this.associations.set(l,a);for(const[c,d]of n.children.entries())i(d,l.children[c])};return i(r,s),s.name+="_instance_"+e.uses[t]++,s}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let r=0;r<t.length;r++){const s=e(t[r]);if(s)return s}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const r=[];for(let s=0;s<t.length;s++){const i=e(t[s]);i&&r.push(i)}return r}getDependency(e,t){const r=e+":"+t;let s=this.cache.get(r);if(!s){switch(e){case"scene":s=this.loadScene(t);break;case"node":s=this.loadNode(t);break;case"mesh":s=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":s=this.loadAccessor(t);break;case"bufferView":s=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":s=this.loadBuffer(t);break;case"material":s=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":s=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":s=this.loadSkin(t);break;case"animation":s=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":s=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(r,s)}return s}getDependencies(e){let t=this.cache.get(e);if(!t){const r=this;t=Promise.all((this.json[e+("mesh"===e?"es":"s")]||[]).map(function(i,n){return r.getDependency(e,n)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],r=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[_.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(i,n){r.load(o.Zp0.resolveURL(t.uri,s.path),i,void 0,function(){n(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(r){const i=t.byteOffset||0;return r.slice(i,i+(t.byteLength||0))})}loadAccessor(e){const t=this,r=this.json,s=this.json.accessors[e];if(void 0===s.bufferView&&void 0===s.sparse)return Promise.resolve(null);const i=[];return i.push(void 0!==s.bufferView?this.getDependency("bufferView",s.bufferView):null),void 0!==s.sparse&&(i.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(i).then(function(n){const l=n[0],a=G[s.type],c=W[s.componentType],d=c.BYTES_PER_ELEMENT,x=s.byteOffset||0,S=void 0!==s.bufferView?r.bufferViews[s.bufferView].byteStride:void 0,B=!0===s.normalized;let N,L;if(S&&S!==d*a){const I=Math.floor(x/S),ee="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+I+":"+s.count;let H=t.cache.get(ee);H||(N=new c(l,I*S,s.count*S/d),H=new o.vpT(N,S/d),t.cache.add(ee,H)),L=new o.kB5(H,a,x%S/d,B)}else N=null===l?new c(s.count*a):new c(l,x,s.count*a),L=new o.TlE(N,a,B);if(void 0!==s.sparse){const xe=s.sparse.values.byteOffset||0,de=new(0,W[s.sparse.indices.componentType])(n[1],s.sparse.indices.byteOffset||0,s.sparse.count*G.SCALAR),oe=new c(n[2],xe,s.sparse.count*a);null!==l&&(L=new o.TlE(L.array.slice(),L.itemSize,L.normalized));for(let se=0,me=de.length;se<me;se++){const ge=de[se];if(L.setX(ge,oe[se*a]),a>=2&&L.setY(ge,oe[se*a+1]),a>=3&&L.setZ(ge,oe[se*a+2]),a>=4&&L.setW(ge,oe[se*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return L})}loadTexture(e){const t=this.json,i=t.textures[e].source,n=t.images[i];let l=this.textureLoader;if(n.uri){const a=this.options.manager.getHandler(n.uri);null!==a&&(l=a)}return this.loadTextureImage(e,i,l)}loadTextureImage(e,t,r){const s=this,i=this.json,n=i.textures[e],l=i.images[t],a=(l.uri||l.bufferView)+":"+n.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(t,r).then(function(d){d.flipY=!1,n.name&&(d.name=n.name);const x=(i.samplers||{})[n.sampler]||{};return d.magFilter=X[x.magFilter]||o.wem,d.minFilter=X[x.minFilter]||o.D1R,d.wrapS=$[x.wrapS]||o.rpg,d.wrapT=$[x.wrapT]||o.rpg,s.associations.set(d,{textures:e}),d}).catch(function(){return null});return this.textureCache[a]=c,c}loadImageSource(e,t){const s=this.json,i=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then(u=>u.clone());const n=s.images[e],l=self.URL||self.webkitURL;let a=n.uri||"",c=!1;if(void 0!==n.bufferView)a=this.getDependency("bufferView",n.bufferView).then(function(u){c=!0;const x=new Blob([u],{type:n.mimeType});return a=l.createObjectURL(x),a});else if(void 0===n.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const d=Promise.resolve(a).then(function(u){return new Promise(function(x,S){let B=x;!0===t.isImageBitmapLoader&&(B=function(N){const L=new o.xEZ(N);L.needsUpdate=!0,x(L)}),t.load(o.Zp0.resolveURL(u,i.path),B,void 0,S)})}).then(function(u){return!0===c&&l.revokeObjectURL(a),u.userData.mimeType=n.mimeType||function Ce(p){return p.search(/\.jpe?g($|\?)/i)>0||0===p.search(/^data\:image\/jpeg/)?"image/jpeg":p.search(/\.webp($|\?)/i)>0||0===p.search(/^data\:image\/webp/)?"image/webp":"image/png"}(n.uri),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),u});return this.sourceCache[e]=d,d}assignTexture(e,t,r,s){const i=this;return this.getDependency("texture",r.index).then(function(n){if(void 0!==r.texCoord&&0!=r.texCoord&&!("aoMap"===t&&1==r.texCoord)&&console.warn("THREE.GLTFLoader: Custom UV set "+r.texCoord+" for texture "+t+" not yet supported."),i.extensions[_.KHR_TEXTURE_TRANSFORM]){const l=void 0!==r.extensions?r.extensions[_.KHR_TEXTURE_TRANSFORM]:void 0;if(l){const a=i.associations.get(n);n=i.extensions[_.KHR_TEXTURE_TRANSFORM].extendTexture(n,l),i.associations.set(n,a)}}return void 0!==s&&(n.encoding=s),e[t]=n,n})}assignFinalMaterial(e){const t=e.geometry;let r=e.material;const s=void 0===t.attributes.tangent,i=void 0!==t.attributes.color,n=void 0===t.attributes.normal;if(e.isPoints){const l="PointsMaterial:"+r.uuid;let a=this.cache.get(l);a||(a=new o.UY4,o.F5T.prototype.copy.call(a,r),a.color.copy(r.color),a.map=r.map,a.sizeAttenuation=!1,this.cache.add(l,a)),r=a}else if(e.isLine){const l="LineBasicMaterial:"+r.uuid;let a=this.cache.get(l);a||(a=new o.nls,o.F5T.prototype.copy.call(a,r),a.color.copy(r.color),this.cache.add(l,a)),r=a}if(s||i||n){let l="ClonedMaterial:"+r.uuid+":";r.isGLTFSpecularGlossinessMaterial&&(l+="specular-glossiness:"),s&&(l+="derivative-tangents:"),i&&(l+="vertex-colors:"),n&&(l+="flat-shading:");let a=this.cache.get(l);a||(a=r.clone(),i&&(a.vertexColors=!0),n&&(a.flatShading=!0),s&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(l,a),this.associations.set(a,this.associations.get(r))),r=a}r.aoMap&&void 0===t.attributes.uv2&&void 0!==t.attributes.uv&&t.setAttribute("uv2",t.attributes.uv),e.material=r}getMaterialType(){return o.Wid}loadMaterial(e){const t=this,s=this.extensions,i=this.json.materials[e];let n;const l={},a=i.extensions||{},c=[];if(a[_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const u=s[_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];n=u.getMaterialType(),c.push(u.extendParams(l,i,t))}else if(a[_.KHR_MATERIALS_UNLIT]){const u=s[_.KHR_MATERIALS_UNLIT];n=u.getMaterialType(),c.push(u.extendParams(l,i,t))}else{const u=i.pbrMetallicRoughness||{};if(l.color=new o.Ilk(1,1,1),l.opacity=1,Array.isArray(u.baseColorFactor)){const x=u.baseColorFactor;l.color.fromArray(x),l.opacity=x[3]}void 0!==u.baseColorTexture&&c.push(t.assignTexture(l,"map",u.baseColorTexture,o.knz)),l.metalness=void 0!==u.metallicFactor?u.metallicFactor:1,l.roughness=void 0!==u.roughnessFactor?u.roughnessFactor:1,void 0!==u.metallicRoughnessTexture&&(c.push(t.assignTexture(l,"metalnessMap",u.metallicRoughnessTexture)),c.push(t.assignTexture(l,"roughnessMap",u.metallicRoughnessTexture))),n=this._invokeOne(function(x){return x.getMaterialType&&x.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(x){return x.extendMaterialParams&&x.extendMaterialParams(e,l)})))}!0===i.doubleSided&&(l.side=o.ehD);const d=i.alphaMode||"OPAQUE";if("BLEND"===d?(l.transparent=!0,l.depthWrite=!1):(l.transparent=!1,"MASK"===d&&(l.alphaTest=void 0!==i.alphaCutoff?i.alphaCutoff:.5)),void 0!==i.normalTexture&&n!==o.vBJ&&(c.push(t.assignTexture(l,"normalMap",i.normalTexture)),l.normalScale=new o.FM8(1,1),void 0!==i.normalTexture.scale)){const u=i.normalTexture.scale;l.normalScale.set(u,u)}return void 0!==i.occlusionTexture&&n!==o.vBJ&&(c.push(t.assignTexture(l,"aoMap",i.occlusionTexture)),void 0!==i.occlusionTexture.strength&&(l.aoMapIntensity=i.occlusionTexture.strength)),void 0!==i.emissiveFactor&&n!==o.vBJ&&(l.emissive=(new o.Ilk).fromArray(i.emissiveFactor)),void 0!==i.emissiveTexture&&n!==o.vBJ&&c.push(t.assignTexture(l,"emissiveMap",i.emissiveTexture,o.knz)),Promise.all(c).then(function(){let u;return u=n===te?s[_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(l):new n(l),i.name&&(u.name=i.name),F(u,i),t.associations.set(u,{materials:e}),i.extensions&&ue(s,u,i),u})}createUniqueName(e){const t=o.iUV.sanitizeNodeName(e||"");let r=t;for(let s=1;this.nodeNamesUsed[r];++s)r=t+"_"+s;return this.nodeNamesUsed[r]=!0,r}loadGeometries(e){const t=this,r=this.extensions,s=this.primitiveCache;function i(l){return r[_.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(l,t).then(function(a){return ye(a,l,t)})}const n=[];for(let l=0,a=e.length;l<a;l++){const c=e[l],d=Ae(c),u=s[d];if(u)n.push(u.promise);else{let x;x=c.extensions&&c.extensions[_.KHR_DRACO_MESH_COMPRESSION]?i(c):ye(new o.u9r,c,t),s[d]={primitive:c,promise:x},n.push(x)}}return Promise.all(n)}loadMesh(e){const t=this,s=this.extensions,i=this.json.meshes[e],n=i.primitives,l=[];for(let a=0,c=n.length;a<c;a++){const d=void 0===n[a].material?(void 0===(p=this.cache).DefaultMaterial&&(p.DefaultMaterial=new o.Wid({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:o.Wl3})),p.DefaultMaterial):this.getDependency("material",n[a].material);l.push(d)}var p;return l.push(t.loadGeometries(n)),Promise.all(l).then(function(a){const c=a.slice(0,a.length-1),d=a[a.length-1],u=[];for(let S=0,B=d.length;S<B;S++){const N=d[S],L=n[S];let I;const ee=c[S];if(4===L.mode||5===L.mode||6===L.mode||void 0===L.mode)I=!0===i.isSkinnedMesh?new o.TUv(N,ee):new o.Kj0(N,ee),!0===I.isSkinnedMesh&&!I.geometry.attributes.skinWeight.normalized&&I.normalizeSkinWeights(),5===L.mode?I.geometry=we(I.geometry,o.UlW):6===L.mode&&(I.geometry=we(I.geometry,o.z$h));else if(1===L.mode)I=new o.ejS(N,ee);else if(3===L.mode)I=new o.x12(N,ee);else if(2===L.mode)I=new o.blk(N,ee);else{if(0!==L.mode)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+L.mode);I=new o.woe(N,ee)}Object.keys(I.geometry.morphAttributes).length>0&&Re(I,i),I.name=t.createUniqueName(i.name||"mesh_"+e),F(I,i),L.extensions&&ue(s,I,L),t.assignFinalMaterial(I),u.push(I)}for(let S=0,B=u.length;S<B;S++)t.associations.set(u[S],{meshes:e,primitives:S});if(1===u.length)return u[0];const x=new o.ZAu;t.associations.set(x,{meshes:e});for(let S=0,B=u.length;S<B;S++)x.add(u[S]);return x})}loadCamera(e){let t;const r=this.json.cameras[e],s=r[r.type];if(s)return"perspective"===r.type?t=new o.cPb(o.M8C.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):"orthographic"===r.type&&(t=new o.iKG(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),r.name&&(t.name=this.createUniqueName(r.name)),F(t,r),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],r={joints:t.joints};return void 0===t.inverseBindMatrices?Promise.resolve(r):this.getDependency("accessor",t.inverseBindMatrices).then(function(s){return r.inverseBindMatrices=s,r})}loadAnimation(e){const r=this.json.animations[e],s=[],i=[],n=[],l=[],a=[];for(let c=0,d=r.channels.length;c<d;c++){const u=r.channels[c],x=r.samplers[u.sampler],S=u.target,N=void 0!==r.parameters?r.parameters[x.input]:x.input,L=void 0!==r.parameters?r.parameters[x.output]:x.output;s.push(this.getDependency("node",void 0!==S.node?S.node:S.id)),i.push(this.getDependency("accessor",N)),n.push(this.getDependency("accessor",L)),l.push(x),a.push(S)}return Promise.all([Promise.all(s),Promise.all(i),Promise.all(n),Promise.all(l),Promise.all(a)]).then(function(c){const d=c[0],u=c[1],x=c[2],S=c[3],B=c[4],N=[];for(let I=0,ee=d.length;I<ee;I++){const H=d[I],xe=u[I],de=x[I],oe=S[I],se=B[I];if(void 0===H)continue;let me;switch(H.updateMatrix(),H.matrixAutoUpdate=!0,Z[se.path]){case Z.weights:me=o.dUE;break;case Z.rotation:me=o.iLg;break;default:me=o.yC1}const ge=H.name?H.name:H.uuid,Oe=void 0!==oe.interpolation?ie[oe.interpolation]:o.NMF,ve=[];Z[se.path]===Z.weights?H.traverse(function(le){le.morphTargetInfluences&&ve.push(le.name?le.name:le.uuid)}):ve.push(ge);let Te=de.array;if(de.normalized){const le=Me(Te.constructor),_e=new Float32Array(Te.length);for(let he=0,be=Te.length;he<be;he++)_e[he]=Te[he]*le;Te=_e}for(let le=0,_e=ve.length;le<_e;le++){const he=new me(ve[le]+"."+Z[se.path],xe.array,Te,Oe);"CUBICSPLINE"===oe.interpolation&&(he.createInterpolant=function(Pe){return new(this instanceof o.iLg?D:U)(this.times,this.values,this.getValueSize()/3,Pe)},he.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),N.push(he)}}return new o.m7l(r.name?r.name:"animation_"+e,void 0,N)})}createNodeMesh(e){const r=this,s=this.json.nodes[e];return void 0===s.mesh?null:r.getDependency("mesh",s.mesh).then(function(i){const n=r._getNodeRef(r.meshCache,s.mesh,i);return void 0!==s.weights&&n.traverse(function(l){if(l.isMesh)for(let a=0,c=s.weights.length;a<c;a++)l.morphTargetInfluences[a]=s.weights[a]}),n})}loadNode(e){const r=this.extensions,s=this,i=this.json.nodes[e],n=i.name?s.createUniqueName(i.name):"";return function(){const l=[],a=s._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return a&&l.push(a),void 0!==i.camera&&l.push(s.getDependency("camera",i.camera).then(function(c){return s._getNodeRef(s.cameraCache,i.camera,c)})),s._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){l.push(c)}),Promise.all(l)}().then(function(l){let a;if(a=!0===i.isBone?new o.N$j:l.length>1?new o.ZAu:1===l.length?l[0]:new o.Tme,a!==l[0])for(let c=0,d=l.length;c<d;c++)a.add(l[c]);if(i.name&&(a.userData.name=i.name,a.name=n),F(a,i),i.extensions&&ue(r,a,i),void 0!==i.matrix){const c=new o.yGw;c.fromArray(i.matrix),a.applyMatrix4(c)}else void 0!==i.translation&&a.position.fromArray(i.translation),void 0!==i.rotation&&a.quaternion.fromArray(i.rotation),void 0!==i.scale&&a.scale.fromArray(i.scale);return s.associations.has(a)||s.associations.set(a,{}),s.associations.get(a).nodes=e,a})}loadScene(e){const t=this.json,r=this.extensions,s=this.json.scenes[e],i=this,n=new o.ZAu;s.name&&(n.name=i.createUniqueName(s.name)),F(n,s),s.extensions&&ue(r,n,s);const l=s.nodes||[],a=[];for(let c=0,d=l.length;c<d;c++)a.push(Ee(l[c],n,t,i));return Promise.all(a).then(function(){return i.associations=(d=>{const u=new Map;for(const[x,S]of i.associations)(x instanceof o.F5T||x instanceof o.xEZ)&&u.set(x,S);return d.traverse(x=>{const S=i.associations.get(x);null!=S&&u.set(x,S)}),u})(n),n})}}function Ee(p,e,t,r){const s=t.nodes[p];return r.getDependency("node",p).then(function(i){if(void 0===s.skin)return i;let n;return r.getDependency("skin",s.skin).then(function(l){n=l;const a=[];for(let c=0,d=n.joints.length;c<d;c++)a.push(r.getDependency("node",n.joints[c]));return Promise.all(a)}).then(function(l){return i.traverse(function(a){if(!a.isMesh)return;const c=[],d=[];for(let u=0,x=l.length;u<x;u++){const S=l[u];if(S){c.push(S);const B=new o.yGw;void 0!==n.inverseBindMatrices&&B.fromArray(n.inverseBindMatrices.array,16*u),d.push(B)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',n.joints[u])}a.bind(new o.OdW(c,d),a.matrixWorld)}),i})}).then(function(i){e.add(i);const n=[];if(s.children){const l=s.children;for(let a=0,c=l.length;a<c;a++)n.push(Ee(l[a],i,t,r))}return Promise.all(n)})}function ye(p,e,t){const r=e.attributes,s=[];function i(n,l){return t.getDependency("accessor",n).then(function(a){p.setAttribute(l,a)})}for(const n in r){const l=Q[n]||n.toLowerCase();l in p.attributes||s.push(i(r[n],l))}if(void 0!==e.indices&&!p.index){const n=t.getDependency("accessor",e.indices).then(function(l){p.setIndex(l)});s.push(n)}return F(p,e),function Ie(p,e,t){const r=e.attributes,s=new o.ZzF;if(void 0===r.POSITION)return;{const l=t.json.accessors[r.POSITION],a=l.min,c=l.max;if(void 0===a||void 0===c)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(s.set(new o.Pa4(a[0],a[1],a[2]),new o.Pa4(c[0],c[1],c[2])),l.normalized){const d=Me(W[l.componentType]);s.min.multiplyScalar(d),s.max.multiplyScalar(d)}}const i=e.targets;if(void 0!==i){const l=new o.Pa4,a=new o.Pa4;for(let c=0,d=i.length;c<d;c++){const u=i[c];if(void 0!==u.POSITION){const x=t.json.accessors[u.POSITION],S=x.min,B=x.max;if(void 0!==S&&void 0!==B){if(a.setX(Math.max(Math.abs(S[0]),Math.abs(B[0]))),a.setY(Math.max(Math.abs(S[1]),Math.abs(B[1]))),a.setZ(Math.max(Math.abs(S[2]),Math.abs(B[2]))),x.normalized){const N=Me(W[x.componentType]);a.multiplyScalar(N)}l.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(l)}p.boundingBox=s;const n=new o.aLr;s.getCenter(n.center),n.radius=s.min.distanceTo(s.max)/2,p.boundingSphere=n}(p,e,t),Promise.all(s).then(function(){return void 0!==e.targets?function ae(p,e,t){let r=!1,s=!1,i=!1;for(let c=0,d=e.length;c<d;c++){const u=e[c];if(void 0!==u.POSITION&&(r=!0),void 0!==u.NORMAL&&(s=!0),void 0!==u.COLOR_0&&(i=!0),r&&s&&i)break}if(!r&&!s&&!i)return Promise.resolve(p);const n=[],l=[],a=[];for(let c=0,d=e.length;c<d;c++){const u=e[c];if(r){const x=void 0!==u.POSITION?t.getDependency("accessor",u.POSITION):p.attributes.position;n.push(x)}if(s){const x=void 0!==u.NORMAL?t.getDependency("accessor",u.NORMAL):p.attributes.normal;l.push(x)}if(i){const x=void 0!==u.COLOR_0?t.getDependency("accessor",u.COLOR_0):p.attributes.color;a.push(x)}}return Promise.all([Promise.all(n),Promise.all(l),Promise.all(a)]).then(function(c){const u=c[1],x=c[2];return r&&(p.morphAttributes.position=c[0]),s&&(p.morphAttributes.normal=u),i&&(p.morphAttributes.color=x),p.morphTargetsRelative=!0,p})}(p,e.targets,t):p})}function we(p,e){let t=p.getIndex();if(null===t){const n=[],l=p.getAttribute("position");if(void 0===l)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),p;for(let a=0;a<l.count;a++)n.push(a);p.setIndex(n),t=p.getIndex()}const r=t.count-2,s=[];if(e===o.z$h)for(let n=1;n<=r;n++)s.push(t.getX(0)),s.push(t.getX(n)),s.push(t.getX(n+1));else for(let n=0;n<r;n++)n%2==0?(s.push(t.getX(n)),s.push(t.getX(n+1)),s.push(t.getX(n+2))):(s.push(t.getX(n+2)),s.push(t.getX(n+1)),s.push(t.getX(n)));s.length/3!==r&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=p.clone();return i.setIndex(s),i}},5096:(ce,z,O)=>{O.d(z,{L:()=>M});var o=O(6682);const K=/^[og]\s*(.+)?/,Y=/^mtllib /,_=/^usemtl /,E=/^usemap /,g=new o.Pa4,A=new o.Pa4,k=new o.Pa4,w=new o.Pa4,C=new o.Pa4,b=new o.Ilk;function J(){const R={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(m,f){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=m,void(this.object.fromDeclaration=!1!==f);const T=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:m||"",fromDeclaration:!1!==f,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(h,v){const P=this._finalize(!1);P&&(P.inherited||P.groupCount<=0)&&this.materials.splice(P.index,1);const q={index:this.materials.length,name:h||"",mtllib:Array.isArray(v)&&v.length>0?v[v.length-1]:"",smooth:void 0!==P?P.smooth:this.smooth,groupStart:void 0!==P?P.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(ne){const te={index:"number"==typeof ne?ne:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return te.clone=this.clone.bind(te),te}};return this.materials.push(q),q},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(h){const v=this.currentMaterial();if(v&&-1===v.groupEnd&&(v.groupEnd=this.geometry.vertices.length/3,v.groupCount=v.groupEnd-v.groupStart,v.inherited=!1),h&&this.materials.length>1)for(let P=this.materials.length-1;P>=0;P--)this.materials[P].groupCount<=0&&this.materials.splice(P,1);return h&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),v}},T&&T.name&&"function"==typeof T.clone){const h=T.clone(0);h.inherited=!0,this.object.materials.push(h)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(m,f){const T=parseInt(m,10);return 3*(T>=0?T-1:T+f/3)},parseNormalIndex:function(m,f){const T=parseInt(m,10);return 3*(T>=0?T-1:T+f/3)},parseUVIndex:function(m,f){const T=parseInt(m,10);return 2*(T>=0?T-1:T+f/2)},addVertex:function(m,f,T){const h=this.vertices,v=this.object.geometry.vertices;v.push(h[m+0],h[m+1],h[m+2]),v.push(h[f+0],h[f+1],h[f+2]),v.push(h[T+0],h[T+1],h[T+2])},addVertexPoint:function(m){const f=this.vertices;this.object.geometry.vertices.push(f[m+0],f[m+1],f[m+2])},addVertexLine:function(m){const f=this.vertices;this.object.geometry.vertices.push(f[m+0],f[m+1],f[m+2])},addNormal:function(m,f,T){const h=this.normals,v=this.object.geometry.normals;v.push(h[m+0],h[m+1],h[m+2]),v.push(h[f+0],h[f+1],h[f+2]),v.push(h[T+0],h[T+1],h[T+2])},addFaceNormal:function(m,f,T){const h=this.vertices,v=this.object.geometry.normals;g.fromArray(h,m),A.fromArray(h,f),k.fromArray(h,T),C.subVectors(k,A),w.subVectors(g,A),C.cross(w),C.normalize(),v.push(C.x,C.y,C.z),v.push(C.x,C.y,C.z),v.push(C.x,C.y,C.z)},addColor:function(m,f,T){const h=this.colors,v=this.object.geometry.colors;void 0!==h[m]&&v.push(h[m+0],h[m+1],h[m+2]),void 0!==h[f]&&v.push(h[f+0],h[f+1],h[f+2]),void 0!==h[T]&&v.push(h[T+0],h[T+1],h[T+2])},addUV:function(m,f,T){const h=this.uvs,v=this.object.geometry.uvs;v.push(h[m+0],h[m+1]),v.push(h[f+0],h[f+1]),v.push(h[T+0],h[T+1])},addDefaultUV:function(){const m=this.object.geometry.uvs;m.push(0,0),m.push(0,0),m.push(0,0)},addUVLine:function(m){const f=this.uvs;this.object.geometry.uvs.push(f[m+0],f[m+1])},addFace:function(m,f,T,h,v,P,q,ne,te){const pe=this.vertices.length;let V=this.parseVertexIndex(m,pe),U=this.parseVertexIndex(f,pe),y=this.parseVertexIndex(T,pe);if(this.addVertex(V,U,y),this.addColor(V,U,y),void 0!==q&&""!==q){const D=this.normals.length;V=this.parseNormalIndex(q,D),U=this.parseNormalIndex(ne,D),y=this.parseNormalIndex(te,D),this.addNormal(V,U,y)}else this.addFaceNormal(V,U,y);if(void 0!==h&&""!==h){const D=this.uvs.length;V=this.parseUVIndex(h,D),U=this.parseUVIndex(v,D),y=this.parseUVIndex(P,D),this.addUV(V,U,y),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(m){this.object.geometry.type="Points";const f=this.vertices.length;for(let T=0,h=m.length;T<h;T++){const v=this.parseVertexIndex(m[T],f);this.addVertexPoint(v),this.addColor(v)}},addLineGeometry:function(m,f){this.object.geometry.type="Line";const T=this.vertices.length,h=this.uvs.length;for(let v=0,P=m.length;v<P;v++)this.addVertexLine(this.parseVertexIndex(m[v],T));for(let v=0,P=f.length;v<P;v++)this.addUVLine(this.parseUVIndex(f[v],h))}};return R.startObject("",!1),R}class M extends o.aNw{constructor(m){super(m),this.materials=null}load(m,f,T,h){const v=this,P=new o.hH6(this.manager);P.setPath(this.path),P.setRequestHeader(this.requestHeader),P.setWithCredentials(this.withCredentials),P.load(m,function(q){try{f(v.parse(q))}catch(ne){h?h(ne):console.error(ne),v.manager.itemError(m)}},T,h)}setMaterials(m){return this.materials=m,this}parse(m){const f=new J;-1!==m.indexOf("\r\n")&&(m=m.replace(/\r\n/g,"\n")),-1!==m.indexOf("\\\n")&&(m=m.replace(/\\\n/g,""));const T=m.split("\n");let h="",v="",P=0,q=[];const ne="function"==typeof"".trimLeft;for(let V=0,U=T.length;V<U;V++)if(h=T[V],h=ne?h.trimLeft():h.trim(),P=h.length,0!==P&&(v=h.charAt(0),"#"!==v))if("v"===v){const y=h.split(/\s+/);switch(y[0]){case"v":f.vertices.push(parseFloat(y[1]),parseFloat(y[2]),parseFloat(y[3])),y.length>=7?(b.setRGB(parseFloat(y[4]),parseFloat(y[5]),parseFloat(y[6])).convertSRGBToLinear(),f.colors.push(b.r,b.g,b.b)):f.colors.push(void 0,void 0,void 0);break;case"vn":f.normals.push(parseFloat(y[1]),parseFloat(y[2]),parseFloat(y[3]));break;case"vt":f.uvs.push(parseFloat(y[1]),parseFloat(y[2]))}}else if("f"===v){const D=h.slice(1).trim().split(/\s+/),j=[];for(let X=0,$=D.length;X<$;X++){const G=D[X];if(G.length>0){const Q=G.split("/");j.push(Q)}}const W=j[0];for(let X=1,$=j.length-1;X<$;X++){const G=j[X],Q=j[X+1];f.addFace(W[0],G[0],Q[0],W[1],G[1],Q[1],W[2],G[2],Q[2])}}else if("l"===v){const y=h.substring(1).trim().split(" ");let D=[];const j=[];if(-1===h.indexOf("/"))D=y;else for(let W=0,X=y.length;W<X;W++){const $=y[W].split("/");""!==$[0]&&D.push($[0]),""!==$[1]&&j.push($[1])}f.addLineGeometry(D,j)}else if("p"===v){const D=h.slice(1).trim().split(" ");f.addPointGeometry(D)}else if(null!==(q=K.exec(h))){const y=(" "+q[0].slice(1).trim()).slice(1);f.startObject(y)}else if(_.test(h))f.object.startMaterial(h.substring(7).trim(),f.materialLibraries);else if(Y.test(h))f.materialLibraries.push(h.substring(7).trim());else if(E.test(h))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===v){if(q=h.split(" "),q.length>1){const D=q[1].trim().toLowerCase();f.object.smooth="0"!==D&&"off"!==D}else f.object.smooth=!0;const y=f.object.currentMaterial();y&&(y.smooth=f.object.smooth)}else{if("\0"===h)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+h+'"')}f.finalize();const te=new o.ZAu;if(te.materialLibraries=[].concat(f.materialLibraries),1==!(1===f.objects.length&&0===f.objects[0].geometry.vertices.length))for(let V=0,U=f.objects.length;V<U;V++){const y=f.objects[V],D=y.geometry,j=y.materials,W="Line"===D.type,X="Points"===D.type;let $=!1;if(0===D.vertices.length)continue;const G=new o.u9r;G.setAttribute("position",new o.a$l(D.vertices,3)),D.normals.length>0&&G.setAttribute("normal",new o.a$l(D.normals,3)),D.colors.length>0&&($=!0,G.setAttribute("color",new o.a$l(D.colors,3))),!0===D.hasUVIndices&&G.setAttribute("uv",new o.a$l(D.uvs,2));const Q=[];for(let ie=0,fe=j.length;ie<fe;ie++){const re=j[ie],ue=re.name+"_"+re.smooth+"_"+$;let F=f.materials[ue];if(null!==this.materials)if(F=this.materials.create(re.name),!W||!F||F instanceof o.nls){if(X&&F&&!(F instanceof o.UY4)){const ae=new o.UY4({size:10,sizeAttenuation:!1});o.F5T.prototype.copy.call(ae,F),ae.color.copy(F.color),ae.map=F.map,F=ae}}else{const ae=new o.nls;o.F5T.prototype.copy.call(ae,F),ae.color.copy(F.color),F=ae}void 0===F&&(F=W?new o.nls:X?new o.UY4({size:1,sizeAttenuation:!1}):new o.xoR,F.name=re.name,F.flatShading=!re.smooth,F.vertexColors=$,f.materials[ue]=F),Q.push(F)}let Z;if(Q.length>1){for(let ie=0,fe=j.length;ie<fe;ie++){const re=j[ie];G.addGroup(re.groupStart,re.groupCount,ie)}Z=W?new o.ejS(G,Q):X?new o.woe(G,Q):new o.Kj0(G,Q)}else Z=W?new o.ejS(G,Q[0]):X?new o.woe(G,Q[0]):new o.Kj0(G,Q[0]);Z.name=y.name,te.add(Z)}else if(f.vertices.length>0){const V=new o.UY4({size:1,sizeAttenuation:!1}),U=new o.u9r;U.setAttribute("position",new o.a$l(f.vertices,3)),f.colors.length>0&&void 0!==f.colors[0]&&(U.setAttribute("color",new o.a$l(f.colors,3)),V.vertexColors=!0);const y=new o.woe(U,V);te.add(y)}return te}}},9018:(ce,z,O)=>{O.d(z,{xC:()=>A});var o=O(6682),K=O(9097),Y=O(9263),_=O(8648);class E extends _.w{constructor(M,R){super(),this.scene=M,this.camera=R,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(M,R,m){const f=M.getContext(),T=M.state;let h,v;T.buffers.color.setMask(!1),T.buffers.depth.setMask(!1),T.buffers.color.setLocked(!0),T.buffers.depth.setLocked(!0),this.inverse?(h=0,v=1):(h=1,v=0),T.buffers.stencil.setTest(!0),T.buffers.stencil.setOp(f.REPLACE,f.REPLACE,f.REPLACE),T.buffers.stencil.setFunc(f.ALWAYS,h,4294967295),T.buffers.stencil.setClear(v),T.buffers.stencil.setLocked(!0),M.setRenderTarget(m),this.clear&&M.clear(),M.render(this.scene,this.camera),M.setRenderTarget(R),this.clear&&M.clear(),M.render(this.scene,this.camera),T.buffers.color.setLocked(!1),T.buffers.depth.setLocked(!1),T.buffers.stencil.setLocked(!1),T.buffers.stencil.setFunc(f.EQUAL,1,4294967295),T.buffers.stencil.setOp(f.KEEP,f.KEEP,f.KEEP),T.buffers.stencil.setLocked(!0)}}class g extends _.w{constructor(){super(),this.needsSwap=!1}render(M){M.state.buffers.stencil.setLocked(!1),M.state.buffers.stencil.setTest(!1)}}class A{constructor(M,R){if(this.renderer=M,void 0===R){const m=M.getSize(new o.FM8);this._pixelRatio=M.getPixelRatio(),this._width=m.width,this._height=m.height,(R=new o.dd2(this._width*this._pixelRatio,this._height*this._pixelRatio)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=R.width,this._height=R.height;this.renderTarget1=R,this.renderTarget2=R.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===K.C&&console.error("THREE.EffectComposer relies on CopyShader"),void 0===Y.T&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new Y.T(K.C),this.clock=new o.SUY}swapBuffers(){const M=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=M}addPass(M){this.passes.push(M),M.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(M,R){this.passes.splice(R,0,M),M.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(M){const R=this.passes.indexOf(M);-1!==R&&this.passes.splice(R,1)}isLastEnabledPass(M){for(let R=M+1;R<this.passes.length;R++)if(this.passes[R].enabled)return!1;return!0}render(M){void 0===M&&(M=this.clock.getDelta());const R=this.renderer.getRenderTarget();let m=!1;for(let f=0,T=this.passes.length;f<T;f++){const h=this.passes[f];if(!1!==h.enabled){if(h.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(f),h.render(this.renderer,this.writeBuffer,this.readBuffer,M,m),h.needsSwap){if(m){const v=this.renderer.getContext(),P=this.renderer.state.buffers.stencil;P.setFunc(v.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,M),P.setFunc(v.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==E&&(h instanceof E?m=!0:h instanceof g&&(m=!1))}}this.renderer.setRenderTarget(R)}reset(M){if(void 0===M){const R=this.renderer.getSize(new o.FM8);this._pixelRatio=this.renderer.getPixelRatio(),this._width=R.width,this._height=R.height,(M=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=M,this.renderTarget2=M.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(M,R){this._width=M,this._height=R;const m=this._width*this._pixelRatio,f=this._height*this._pixelRatio;this.renderTarget1.setSize(m,f),this.renderTarget2.setSize(m,f);for(let T=0;T<this.passes.length;T++)this.passes[T].setSize(m,f)}setPixelRatio(M){this._pixelRatio=M,this.setSize(this._width,this._height)}}new o.iKG(-1,1,1,-1,0,1);const C=new o.u9r;C.setAttribute("position",new o.a$l([-1,3,0,-1,-1,0,3,-1,0],3)),C.setAttribute("uv",new o.a$l([0,2,0,0,2,0],2))},3386:(ce,z,O)=>{O.d(z,{f:()=>_});var o=O(6682),K=O(8648),Y=O(9097);class _ extends K.w{constructor(g,A,k,w){super(),this.renderScene=A,this.renderCamera=k,this.selectedObjects=void 0!==w?w:[],this.visibleEdgeColor=new o.Ilk(1,1,1),this.hiddenEdgeColor=new o.Ilk(.1,.04,.02),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,this._visibilityCache=new Map,this.resolution=void 0!==g?new o.FM8(g.x,g.y):new o.FM8(256,256);const C=Math.round(this.resolution.x/this.downSampleRatio),b=Math.round(this.resolution.y/this.downSampleRatio);this.renderTargetMaskBuffer=new o.dd2(this.resolution.x,this.resolution.y),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.depthMaterial=new o.lRF,this.depthMaterial.side=o.ehD,this.depthMaterial.depthPacking=o.mSO,this.depthMaterial.blending=o.jFi,this.prepareMaskMaterial=this.getPrepareMaskMaterial(),this.prepareMaskMaterial.side=o.ehD,this.prepareMaskMaterial.fragmentShader=function m(f,T){return f.replace(/DEPTH_TO_VIEW_Z/g,(T.isPerspectiveCamera?"perspective":"orthographic")+"DepthToViewZ")}(this.prepareMaskMaterial.fragmentShader,this.renderCamera),this.renderTargetDepthBuffer=new o.dd2(this.resolution.x,this.resolution.y),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new o.dd2(C,b),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new o.dd2(C,b),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new o.dd2(Math.round(C/2),Math.round(b/2)),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new o.dd2(C,b),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new o.dd2(Math.round(C/2),Math.round(b/2)),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1,this.separableBlurMaterial1=this.getSeperableBlurMaterial(4),this.separableBlurMaterial1.uniforms.texSize.value.set(C,b),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeperableBlurMaterial(4),this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(C/2),Math.round(b/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=4,this.overlayMaterial=this.getOverlayMaterial(),void 0===Y.C&&console.error("THREE.OutlinePass relies on CopyShader");const R=Y.C;this.copyUniforms=o.rDY.clone(R.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new o.jyz({uniforms:this.copyUniforms,vertexShader:R.vertexShader,fragmentShader:R.fragmentShader,blending:o.jFi,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new o.Ilk,this.oldClearAlpha=1,this.fsQuad=new K.T(null),this.tempPulseColor1=new o.Ilk,this.tempPulseColor2=new o.Ilk,this.textureMatrix=new o.yGw}dispose(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose()}setSize(g,A){this.renderTargetMaskBuffer.setSize(g,A),this.renderTargetDepthBuffer.setSize(g,A);let k=Math.round(g/this.downSampleRatio),w=Math.round(A/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(k,w),this.renderTargetBlurBuffer1.setSize(k,w),this.renderTargetEdgeBuffer1.setSize(k,w),this.separableBlurMaterial1.uniforms.texSize.value.set(k,w),k=Math.round(k/2),w=Math.round(w/2),this.renderTargetBlurBuffer2.setSize(k,w),this.renderTargetEdgeBuffer2.setSize(k,w),this.separableBlurMaterial2.uniforms.texSize.value.set(k,w)}changeVisibilityOfSelectedObjects(g){const A=this._visibilityCache;function k(w){w.isMesh&&(!0===g?w.visible=A.get(w):(A.set(w,w.visible),w.visible=g))}for(let w=0;w<this.selectedObjects.length;w++)this.selectedObjects[w].traverse(k)}changeVisibilityOfNonSelectedObjects(g){const A=this._visibilityCache,k=[];function w(b){b.isMesh&&k.push(b)}for(let b=0;b<this.selectedObjects.length;b++)this.selectedObjects[b].traverse(w);this.renderScene.traverse(function C(b){if(b.isMesh||b.isSprite){let J=!1;for(let M=0;M<k.length;M++)if(k[M].id===b.id){J=!0;break}if(!1===J){const M=b.visible;(!1===g||!0===A.get(b))&&(b.visible=g),A.set(b,M)}}else(b.isPoints||b.isLine)&&(!0===g?b.visible=A.get(b):(A.set(b,b.visible),b.visible=g))})}updateTextureMatrix(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)}render(g,A,k,w,C){if(this.selectedObjects.length>0){g.getClearColor(this._oldClearColor),this.oldClearAlpha=g.getClearAlpha();const b=g.autoClear;g.autoClear=!1,C&&g.state.buffers.stencil.setTest(!1),g.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1);const J=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,g.setRenderTarget(this.renderTargetDepthBuffer),g.clear(),g.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this._visibilityCache.clear(),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,g.setRenderTarget(this.renderTargetMaskBuffer),g.clear(),g.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this._visibilityCache.clear(),this.renderScene.background=J,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,g.setRenderTarget(this.renderTargetMaskDownSampleBuffer),g.clear(),this.fsQuad.render(g),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){const M=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2;this.tempPulseColor1.multiplyScalar(M),this.tempPulseColor2.multiplyScalar(M)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,g.setRenderTarget(this.renderTargetEdgeBuffer1),g.clear(),this.fsQuad.render(g),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=_.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,g.setRenderTarget(this.renderTargetBlurBuffer1),g.clear(),this.fsQuad.render(g),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=_.BlurDirectionY,g.setRenderTarget(this.renderTargetEdgeBuffer1),g.clear(),this.fsQuad.render(g),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=_.BlurDirectionX,g.setRenderTarget(this.renderTargetBlurBuffer2),g.clear(),this.fsQuad.render(g),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=_.BlurDirectionY,g.setRenderTarget(this.renderTargetEdgeBuffer2),g.clear(),this.fsQuad.render(g),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,C&&g.state.buffers.stencil.setTest(!0),g.setRenderTarget(k),this.fsQuad.render(g),g.setClearColor(this._oldClearColor,this.oldClearAlpha),g.autoClear=b}this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=k.texture,g.setRenderTarget(null),this.fsQuad.render(g))}getPrepareMaskMaterial(){return new o.jyz({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new o.FM8(.5,.5)},textureMatrix:{value:null}},vertexShader:"#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}",fragmentShader:"#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}"})}getEdgeDetectionMaterial(){return new o.jyz({uniforms:{maskTexture:{value:null},texSize:{value:new o.FM8(.5,.5)},visibleEdgeColor:{value:new o.Pa4(1,1,1)},hiddenEdgeColor:{value:new o.Pa4(1,1,1)}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}"})}getSeperableBlurMaterial(g){return new o.jyz({defines:{MAX_RADIUS:g},uniforms:{colorTexture:{value:null},texSize:{value:new o.FM8(.5,.5)},direction:{value:new o.FM8(.5,.5)},kernelRadius:{value:1}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}"})}getOverlayMaterial(){return new o.jyz({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}",blending:o.WMw,depthTest:!1,depthWrite:!1,transparent:!0})}}_.BlurDirectionX=new o.FM8(1,0),_.BlurDirectionY=new o.FM8(0,1)},8648:(ce,z,O)=>{O.d(z,{T:()=>E,w:()=>K});var o=O(6682);class K{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const Y=new o.iKG(-1,1,1,-1,0,1),_=new o.u9r;_.setAttribute("position",new o.a$l([-1,3,0,-1,-1,0,3,-1,0],3)),_.setAttribute("uv",new o.a$l([0,2,0,0,2,0],2));class E{constructor(A){this._mesh=new o.Kj0(_,A)}dispose(){this._mesh.geometry.dispose()}render(A){A.render(this._mesh,Y)}get material(){return this._mesh.material}set material(A){this._mesh.material=A}}},321:(ce,z,O)=>{O.d(z,{C:()=>Y});var o=O(6682),K=O(8648);class Y extends K.w{constructor(E,g,A,k,w){super(),this.scene=E,this.camera=g,this.overrideMaterial=A,this.clearColor=k,this.clearAlpha=void 0!==w?w:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new o.Ilk}render(E,g,A){const k=E.autoClear;let w,C;E.autoClear=!1,void 0!==this.overrideMaterial&&(C=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(E.getClearColor(this._oldClearColor),w=E.getClearAlpha(),E.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&E.clearDepth(),E.setRenderTarget(this.renderToScreen?null:A),this.clear&&E.clear(E.autoClearColor,E.autoClearDepth,E.autoClearStencil),E.render(this.scene,this.camera),this.clearColor&&E.setClearColor(this._oldClearColor,w),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=C),E.autoClear=k}}},9263:(ce,z,O)=>{O.d(z,{T:()=>Y});var o=O(6682),K=O(8648);class Y extends K.w{constructor(E,g){super(),this.textureID=void 0!==g?g:"tDiffuse",E instanceof o.jyz?(this.uniforms=E.uniforms,this.material=E):E&&(this.uniforms=o.rDY.clone(E.uniforms),this.material=new o.jyz({defines:Object.assign({},E.defines),uniforms:this.uniforms,vertexShader:E.vertexShader,fragmentShader:E.fragmentShader})),this.fsQuad=new K.T(this.material)}render(E,g,A){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=A.texture),this.fsQuad.material=this.material,this.renderToScreen?(E.setRenderTarget(null),this.fsQuad.render(E)):(E.setRenderTarget(g),this.clear&&E.clear(E.autoClearColor,E.autoClearDepth,E.autoClearStencil),this.fsQuad.render(E))}}},9097:(ce,z,O)=>{O.d(z,{C:()=>o});const o={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"}},4938:(ce,z,O)=>{O.d(z,{g:()=>o});const o={uniforms:{tDiffuse:{value:null},resolution:{value:null},pixelSize:{value:1}},vertexShader:"\n\n\t\tvarying highp vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float pixelSize;\n\t\tuniform vec2 resolution;\n\n\t\tvarying highp vec2 vUv;\n\n\t\tvoid main(){\n\n\t\t\tvec2 dxy = pixelSize / resolution;\n\t\t\tvec2 coord = dxy * floor( vUv / dxy );\n\t\t\tgl_FragColor = texture2D(tDiffuse, coord);\n\n\t\t}"}}}]);